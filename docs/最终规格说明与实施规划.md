# piapi - 极简LLM编码助手网关：最终规格说明与实施规划

## 1. 项目概述

### 1.1 项目使命
`piapi`是一个为小型开发团队设计的、配置驱动的极简API网关。它旨在统一和简化对多种后端大语言模型（LLM）编码助手服务（如 `codex`, `claude code`）的访问。`piapi`为团队成员提供一个稳定、统一的服务入口，同时允许管理员通过修改单一配置文件，精细化地为每个用户指定其使用的上游服务商及API密钥，实现灵活的路由控制和快速的故障恢复。

### 1.2 核心特性
*   **统一服务入口**: 为 `codex` (`cx`) 和 `claude code` (`cc`) 等服务提供统一的 `.../piapi/<service_type>` URL格式。
*   **精细化用户路由**: 可为每个用户独立配置其请求所路由的上游服务商和该服务商的具体命名API密钥。
*   **命名密钥管理**: 上游服务商的API密钥以“名称-值”对的形式进行管理，提升了配置的可读性和可维护性。
*   **配置即代码**: 所有路由策略、用户、服务商信息均通过单一的 `config.yaml` 文件进行管理，方便版本控制。
*   **配置热加载**: 系统在运行时监控配置文件变更，无需重启服务即可平滑应用新配置。
*   **流式传输支持**: 原生支持HTTP流式响应，完美适配LLM的实时输出效果。

## 2. 核心概念与数据模型

系统配置完全由一个 `config.yaml` 文件驱动。

### 2.1 `config.yaml` 数据结构定义

```yaml
#--------------------------------#
# piapi Gateway Configuration    #
# Final Version                  #
#--------------------------------#

# 服务商列表: 定义了所有可用的上游服务提供方
providers:
  - name: "provider-alpha"  # 服务商的唯一标识符
    # 该服务商的API密钥池, 以"名称 -> 值"的映射形式存在
    apiKeys:
      "main-key": "sk-alpha-key-1-active-xxxxxxxxxx"
      "backup-key": "sk-alpha-key-2-backup-xxxxxxxxxx"
    # 该服务商提供的服务列表
    services:
      - type: "cx"  # 服务类型简写 (codex)
        baseUrl: "https://api.provider-alpha.com/v1/engines" # 上游服务的基础URL前缀
        auth:
          mode: "header"           # header | query
          name: "Authorization"    # 当 mode=header 时使用的头部名称
          prefix: "Bearer "        # 会与实际上游密钥拼接形成完整的值
      - type: "cc"  # 服务类型简写 (claude code)
        baseUrl: "https://api.provider-alpha.com/v1/claude" # 基础URL，后续路径透传
        auth:
          mode: "header"
          name: "x-api-key"

  - name: "provider-beta"
    apiKeys:
      "prod-key": "sk-beta-key-1-active-yyyyyyyyyy"
    services:
      - type: "cx"
        baseUrl: "https://api.another-provider.com/codex-proxy"
        auth:
          mode: "query"
          name: "api_key"

# 用户列表: 定义了所有有权访问piapi网关的用户
users:
  - name: "zhangsan" # 用户的易读名称
    apiKey: "piapi-user-key-001-for-zhangsan" # 用户访问网关时需提供的密钥
    # 用户的路由策略: 精确指定使用哪个服务商的哪个Key
    providerName: "provider-alpha"
    providerKeyName: "main-key"

  - name: "lisi"
    apiKey: "piapi-user-key-002-for-lisi"
    providerName: "provider-alpha"    # 李四也用alpha服务商...
    providerKeyName: "backup-key"       # ...但是用的是备用Key, 实现了策略隔离

  - name: "wangwu"
    apiKey: "piapi-user-key-003-for-wangwu"
    providerName: "provider-beta"
    providerKeyName: "prod-key"
```

上述结构补充说明：
* `services[*].baseUrl` 仅表示上游的基础URL，客户端请求中 `/piapi/<service_type>/<rest>` 的 `<rest>` 会原样追加在该基础URL后。若希望锁定具体路径，可直接在 `baseUrl` 中写完整前缀。
* `services[*].auth` 用于为不同服务定制认证方式；`mode` 支持 `header` 与 `query` 两种形式，`name` 分别代表头部名称或查询参数名称，`prefix` 在 `mode=header` 时可选，默认值为 `"Bearer "`。当 `auth` 块缺失时，系统默认使用 `Authorization: Bearer <providerKey>`。

## 3. 功能规格 (Functional Specifications)

### 3.1 Use Case 1: 管理员配置 (Admin Setup)
*   **描述**: 管理员通过编辑 `config.yaml` 文件来完成系统的所有配置和策略调整。
*   **流程**:
    1.  **添加/修改服务商**: 在 `providers` 列表中添加或修改条目，维护其 `name`, `apiKeys` 映射, 和 `services` 列表。
    2.  **添加/修改用户**: 在 `users` 列表中添加或修改条目，为其分配 `name`, 唯一的 `apiKey`, 并明确指定其 `providerName` 和 `providerKeyName`。
    3.  **保存配置**: 保存 `config.yaml` 文件。
*   **系统响应**: `piapi` 服务检测到文件变更后，在数秒内自动、原子地重新加载配置。加载过程会执行完整的语义校验；若新配置失败，网关保留并继续使用旧配置，同时输出结构化的错误日志，以便管理员排查。校验通过后，所有后续请求立即按照新的规则进行处理，整个过程服务不中断。

### 3.2 Use Case 2: 用户请求服务 (User Consumption)
*   **描述**: 终端用户通过HTTP客户端使用 `piapi` 网关。
*   **URL结构**: `http://<gateway_host>:<port>/piapi/<service_type>` (例如: `http://192.168.1.10:9200/piapi/cx`)
*   **认证方式**: 用户需在HTTP请求头中提供其个人密钥：`Authorization: Bearer <user_api_key>`。
*   **核心处理流程**:
    1.  接收到请求，例如 `POST /piapi/cx/completions`。
    2.  从 `Authorization` 头提取用户apiKey `piapi-user-key-001-for-zhangsan`。
    3.  在配置中查找该 `apiKey` 对应的用户 `zhangsan`。若未找到，返回 **`401 Unauthorized`**。
    4.  获取该用户的路由策略: `providerName: "provider-alpha"` 和 `providerKeyName: "main-key"`。
    5.  在 `providers` 列表中查找 `name` 为 `provider-alpha` 的服务商。若未找到，返回 **`500 Internal Server Error`** (表示配置错误)。
    6.  从请求路径中解析出服务类型 `cx` 以及剩余路径片段 `<rest>`（可为空）。
    7.  在 `provider-alpha` 的 `services` 列表中查找 `type: "cx"` 的服务。若未找到，返回 **`404 Not Found`**。
    8.  获取服务的 `baseUrl` 并将 `<rest>` 追加到该基础URL后，形成完整的上游目标地址。
    9.  在 `provider-alpha` 的 `apiKeys` 映射中，查找键为 `main-key` 的值，得到上游Key `sk-alpha-key-1-active-xxx`。若未找到，返回 **`500 Internal Server Error`** (表示配置错误)。
    10. 根据服务配置的 `auth.mode` 和 `auth.name` 将上游Key 注入请求头或查询参数，未显式配置时默认使用 `Authorization: Bearer <key>`。
    11. 将请求（包括方法、头、体、流）转发至上游，并将上游的响应实时回传给原始客户端。

### 3.3 Use Case 3: 故障恢复 (Failure Recovery)
*   **场景**: `provider-alpha` 的 `main-key` 失效，影响了用户 `zhangsan`。
*   **恢复流程**:
    1.  `zhangsan` 报告服务不可用。管理员通过日志发现 `provider-alpha` 针对 `main-key` 的请求返回了 `401/403` 错误。
    2.  管理员编辑 `config.yaml`，仅修改 `zhangsan` 的用户配置，将其 `providerKeyName` 从 `"main-key"` 改为 `"backup-key"`。
    3.  保存文件，`piapi` 自动热加载新配置。
    4.  `zhangsan` 的服务立即恢复，因为他的请求现在被路由到 `provider-alpha` 并使用 `backup-key` 进行认证。此变更对 `lisi` 和 `wangwu` 没有任何影响。

## 4. 非功能性规格 (Non-Functional Specifications)

*   **性能**: 在启用流式转发的情况下，网关额外引入的请求延迟应在5分钟滑动窗口内保持 `P95 < 50ms`；需要通过指标或日志采样进行度量，并避免因缓冲导致的高内存占用和延迟。
*   **日志**: 提供结构化的日志。每条请求日志应至少包含：`Timestamp`, `RequestID`, `UserName`, `ServiceType`, `UpstreamProvider`, `UpstreamKeyName`, `StatusCode`, `Latency`。
*   **错误处理**: 向客户端返回清晰、标准的HTTP状态码。对于内部配置错误，返回 `500` 并记录详细日志；对于客户端错误，返回 `40x`；对于上游服务错误，透传或返回 `502 Bad Gateway`。
*   **安全性**: 作为一个内部工具，依赖API Key认证。假定运行在受信任的内部网络环境中。

## 5. 技术选型与实施规划

### 5.1 推荐技术栈
*   **语言**: **Go (Golang)** - 因其高性能、出色的并发模型和强大的 `net/http` 标准库。
*   **核心库**:
    *   **HTTP代理**: `net/http/httputil.ReverseProxy`
    *   **YAML解析**: `gopkg.in/yaml.v3`
    *   **文件监控**: `github.com/fsnotify/fsnotify`
*   **结构化日志**: `go.uber.org/zap`
*   **指标采集**: `github.com/prometheus/client_golang`
*   **配置管理**: 自行封装一个使用 `sync.RWMutex` 保护的线程安全配置对象。

### 5.2 实施规划 (开发路线图)

**Phase 1: 核心代理与数据结构 (2天)**
*   [x] 初始化Go项目，定义 `config.yaml` 对应的Go `struct` 结构。
*   [x] 实现一个函数，在程序启动时加载并解析 `config.yaml` 文件到内存。
*   [x] **实现核心HTTP Handler**: 完成完整的动态路由逻辑，包括用户认证、查找路由策略、构建并转发请求。
*   [x] 在此阶段，先不实现热加载，确保单次加载配置能完美工作。
*   [x] 建立基础单元测试（`go test`），覆盖配置解析、路由查找和认证注入的关键路径。

**Phase 2: 配置热加载 (1-2天)**
*   [x] 引入 `fsnotify` 库，设置一个goroutine来监控 `config.yaml` 的修改事件。
*   [x] 设计一个线程安全的配置管理器，使用 `sync.RWMutex` 保护配置对象，当文件变更时，解析新配置并原子地替换掉旧的配置指针。
*   [x] 增加配置校验逻辑：在加载新配置时，进行基本的检查（如用户指向的provider和key是否存在），如果校验失败则拒绝加载并打印错误日志，并保持旧配置继续服务。
*   [x] 编写覆盖热加载成功/失败分支的端到端回放测试或脚本，验证回滚机制。

**Phase 3: 日志与可观测性 (1天)**
*   [x] 引入结构化日志库。
*   [x] 为请求处理流程的每个关键步骤（认证、路由决策、转发、完成）添加详细的日志。
*   [x] 实现一个简单的中间件，为每个请求生成一个唯一的 `RequestID`，并贯穿整个日志链。
*   [x] 输出基础指标（如请求计数、延迟分位、配置加载成功/失败次数），为性能目标和运维告警提供基础数据。

**Phase 4: 打包与部署 (1天)**
*   [x] 编写 `Dockerfile` 以便将 `piapi` 应用容器化。
*   [x] 编写一份清晰的 `README.md`，详细说明 `config.yaml` 的配置方法、如何运行服务以及如何获取日志。
*   [x] 交付 `config.yaml.example` 模板文件，方便管理员快速上手。
*   [x] 在目标服务器上部署并进行端到端测试。

## 6. 当前实现状态与交付

*   **Go 版本**: 项目使用 Go 1.23，Docker 镜像基于 `golang:1.23` 构建。
*   **功能覆盖**: 已交付统一网关、配置热加载、Zap 结构化日志、Prometheus 指标（请求计数、延迟、配置重载结果）以及完整的单元/集成测试。
*   **自动化**: GitHub Actions 在 push/PR 时运行 `go test` 和构建流程，对 `main` 与 `v*` 标签自动构建并推送镜像至 `ghcr.io/prehisle/piapi`，附带 `buildcache` 以加速增量构建。
*   **发布产物**: 提供 `config.yaml.example`、`docker-compose.yml`（默认拉取 GHCR 镜像）以及多阶段 `Dockerfile`，支持本地与容器化部署。
*   **后续扩展**: 可按需增加限流、鉴权增强或进一步的部署脚本（如 Helm Chart/系统服务文件）。
