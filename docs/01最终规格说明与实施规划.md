# piapi - 极简LLM编码助手网关：最终规格说明与实施规划

## 1. 项目概述

### 1.1 项目使命
`piapi`是一个为小型开发团队设计的、配置驱动的极简API网关。它旨在统一和简化对多种后端大语言模型（LLM）编码助手服务（如 `codex`, `claude_code`）的访问。`piapi`为团队成员提供一个稳定、统一的服务入口，同时允许管理员通过修改单一配置文件，精细化地为每个用户指定其使用的上游服务商及API密钥，实现灵活的路由控制和快速的故障恢复。

### 1.2 核心特性
*   **统一服务入口**：所有上游服务通过 `/piapi/<service_type>` 暴露，调用方无需关心供应商差异。
*   **用户-服务粒度路由**：同一用户可针对不同服务类型绑定不同供应商或候选集合。
*   **聚合候选与多策略调度**：支持 `round_robin`、`weighted_rr`、`adaptive_rr`（质量自适应加权）、`sticky_healthy`（粘性健康优先）等策略，结合启停标记和权重实现细粒度流量分配。
*   **命名密钥管理**：上游 API Key 以“名称→值”映射维护，可复用并便于审计。
*   **配置即代码**：全部路由、供应商与用户信息由单一 `config.yaml` 驱动，便于版本管理与审计。
*   **配置热加载**：运行期监听配置变动，解析成功后无缝替换；失败时保留旧配置并暴露指标。
*   **流式传输支持**：原生透传 HTTP 流响应，适配 LLM 实时输出。
*   **可观测性内建**：Prometheus 指标、结构化日志以及管理后台候选面板可协助快速排障。

## 2. 核心概念与数据模型

系统配置完全由一个 `config.yaml` 文件驱动。

### 2.1 `config.yaml` 数据结构定义

```yaml
#--------------------------------#
# piapi Gateway Configuration    #
# Final Version                  #
#--------------------------------#

# 服务商列表: 定义了所有可用的上游服务提供方
providers:
  - name: "provider-alpha"  # 服务商的唯一标识符
    # 该服务商的API密钥池, 以"名称 -> 值"的映射形式存在
    apiKeys:
      "main-key": "sk-alpha-key-1-active-xxxxxxxxxx"
      "backup-key": "sk-alpha-key-2-backup-xxxxxxxxxx"
    # 该服务商提供的服务列表
    services:
      - type: "codex"  # 服务类型标识 codex
        baseUrl: "https://api.provider-alpha.com/v1/engines" # 上游服务的基础URL前缀
        auth:
          mode: "header"           # header | query
          name: "Authorization"    # 当 mode=header 时使用的头部名称
          prefix: "Bearer "        # 会与实际上游密钥拼接形成完整的值
      - type: "claude_code"  # 服务类型标识 claude_code
        baseUrl: "https://api.provider-alpha.com/v1/claude" # 基础URL，后续路径透传
        auth:
          mode: "header"
          name: "x-api-key"

  - name: "provider-beta"
    apiKeys:
      "prod-key": "sk-beta-key-1-active-yyyyyyyyyy"
    services:
      - type: "codex"
        baseUrl: "https://api.another-provider.com/codex-proxy"
        auth:
          mode: "query"
          name: "api_key"

# 用户列表: 定义了所有有权访问piapi网关的用户
users:
  - name: "zhangsan" # 用户的易读名称
    apiKey: "piapi-user-key-001-for-zhangsan" # 用户访问网关时需提供的密钥
    services:
      codex:
        providerName: "provider-alpha"
        providerKeyName: "main-key"
      claude_code:
        providerName: "provider-alpha"
        providerKeyName: "backup-key"
      # 若需要聚合多家候选，可开启策略模式（推荐）
      # codex:
      #   strategy: "adaptive_rr"  # round_robin / weighted_rr / adaptive_rr / sticky_healthy
      #   candidates:
      #     - providerName: "provider-alpha"
      #       providerKeyName: "main-key"
      #       weight: 3
      #       enabled: true
      #     - providerName: "provider-beta"
      #       providerKeyName: "prod-key"
      #       weight: 1
      #       enabled: true

  - name: "lisi"
    apiKey: "piapi-user-key-002-for-lisi"
    services:
      codex:
        providerName: "provider-alpha"    # 李四也用alpha服务商...
        providerKeyName: "backup-key"       # ...但是用的是备用Key, 实现了策略隔离

  - name: "wangwu"
    apiKey: "piapi-user-key-003-for-wangwu"
    services:
      codex:
        providerName: "provider-beta"
        providerKeyName: "prod-key"
```

上述结构补充说明：
* `services[*].baseUrl` 仅表示上游的基础URL，客户端请求中 `/piapi/<service_type>/<rest>` 的 `<rest>` 会原样追加在该基础URL后。若希望锁定具体路径，可直接在 `baseUrl` 中写完整前缀。
* `services[*].auth` 用于为不同服务定制认证方式；`mode` 支持 `header` 与 `query` 两种形式，`name` 分别代表头部名称或查询参数名称，`prefix` 在 `mode=header` 时可选，默认值为 `"Bearer "`。当 `auth` 块缺失时，系统默认使用 `Authorization: Bearer <providerKey>`。

## 3. 功能规格 (Functional Specifications)

### 3.1 Use Case 1: 管理员配置 (Admin Setup)
*   **描述**: 管理员通过编辑 `config.yaml` 文件来完成系统的所有配置和策略调整。
*   **流程**:
    1.  **添加/修改服务商**: 在 `providers` 列表中添加或修改条目，维护其 `name`, `apiKeys` 映射, 和 `services` 列表。
    2.  **添加/修改用户**: 在 `users` 列表中添加或修改条目，为其分配 `name`, 唯一的 `apiKey`, 并在 `services` 映射中为每种服务类型配置对应的上游策略。可以继续使用旧版的单提供商配置（`providerName + providerKeyName`），也可以通过 `strategy + candidates[]` 声明多候选上游，并为每个命名 key 设置权重、启停标记与附加标签。
    3.  **保存配置**: 保存 `config.yaml` 文件。
*   **系统响应**: `piapi` 服务检测到文件变更后，在数秒内自动、原子地重新加载配置。加载过程会执行完整的语义校验；若新配置失败，网关保留并继续使用旧配置，同时输出结构化的错误日志，以便管理员排查。校验通过后，所有后续请求立即按照新的规则进行处理，整个过程服务不中断。

### 3.2 Use Case 2: 用户请求服务 (User Consumption)
*   **描述**: 终端用户通过HTTP客户端使用 `piapi` 网关。
*   **URL结构**: `http://<gateway_host>:<port>/piapi/<service_type>` (例如: `http://192.168.1.10:9200/piapi/codex`)
*   **认证方式**: 用户需在HTTP请求头中提供其个人密钥：`Authorization: Bearer <user_api_key>`。
*   **核心处理流程**:
    1.  接收到请求，例如 `POST /piapi/codex/completions`。
    2.  从 `Authorization` 头提取用户apiKey `piapi-user-key-001-for-zhangsan`。
    3.  在配置中查找该 `apiKey` 对应的用户 `zhangsan`。若未找到，返回 **`401 Unauthorized`**。
    4.  从请求路径中解析出服务类型 `codex` 以及剩余路径片段 `<rest>`（可为空）。
    5.  在用户的 `services` 映射中查找 `codex` 的访问策略，获得 `providerName: "provider-alpha"` 和 `providerKeyName: "main-key"`。若缺少该条目，返回 **`404 Not Found`**。
    6.  在 `providers` 列表中查找 `name` 为 `provider-alpha` 的服务商。若未找到，返回 **`500 Internal Server Error`** (表示配置错误)。
    7.  在 `provider-alpha` 的 `services` 列表中查找 `type: "codex"` 的服务。若未找到，返回 **`404 Not Found`**。
    8.  获取服务的 `baseUrl` 并将 `<rest>` 追加到该基础URL后，形成完整的上游目标地址。
    9.  在 `provider-alpha` 的 `apiKeys` 映射中，查找键为 `main-key` 的值，得到上游Key `sk-alpha-key-1-active-xxx`。若未找到，返回 **`500 Internal Server Error`** (表示配置错误)。
    10. 根据服务配置的 `auth.mode` 和 `auth.name` 将上游Key 注入请求头或查询参数，未显式配置时默认使用 `Authorization: Bearer <key>`。
    11. 将请求（包括方法、头、体、流）转发至上游，并将上游的响应实时回传给原始客户端。

### 3.3 Use Case 3: 故障恢复 (Failure Recovery)
*   **场景**: `provider-alpha` 的 `main-key` 失效，影响了用户 `zhangsan` 的 `codex` 服务。
*   **恢复流程**:
    1.  `zhangsan` 报告服务不可用。管理员通过日志发现 `provider-alpha` 针对 `main-key` 的请求返回了 `401/403` 错误。
    2.  管理员编辑 `config.yaml`，仅修改 `zhangsan` 的 `services.codex` 配置，将 `providerKeyName` 从 `"main-key"` 改为 `"backup-key"`。
    3.  保存文件，`piapi` 自动热加载新配置。
    4.  `zhangsan` 的服务立即恢复，因为他的请求现在被路由到 `provider-alpha` 并使用 `backup-key` 进行认证。此变更对 `lisi` 和 `wangwu` 没有任何影响。
*   **自动回退（可选）**: 若同一服务声明了多个候选（例如将 `main-key` 与 `backup-key` 同时写入 `candidates`），系统会基于运行时统计自动隔离短期失败的 key，并按策略（轮询或加权）尝试其他候选，无需人工切换。

## 4. 非功能性规格 (Non-Functional Specifications)

*   **性能**: 在启用流式转发的情况下，网关额外引入的请求延迟应在5分钟滑动窗口内保持 `P95 < 50ms`；需要通过指标或日志采样进行度量，并避免因缓冲导致的高内存占用和延迟。
*   **日志**: 提供结构化的日志。每条请求日志应至少包含：`Timestamp`, `RequestID`, `UserName`, `ServiceType`, `UpstreamProvider`, `UpstreamKeyName`, `StatusCode`, `Latency`。
*   **错误处理**: 向客户端返回清晰、标准的HTTP状态码。对于内部配置错误，返回 `500` 并记录详细日志；对于客户端错误，返回 `40x`；对于上游服务错误，透传或返回 `502 Bad Gateway`。
*   **安全性**: 作为一个内部工具，依赖API Key认证。假定运行在受信任的内部网络环境中。

## 5. 技术选型与实施规划

### 5.1 推荐技术栈
*   **语言**: **Go (Golang)** - 因其高性能、出色的并发模型和强大的 `net/http` 标准库。
*   **核心库**:
    *   **HTTP代理**: `net/http/httputil.ReverseProxy`
    *   **YAML解析**: `gopkg.in/yaml.v3`
    *   **文件监控**: `github.com/fsnotify/fsnotify`
*   **结构化日志**: `go.uber.org/zap`
*   **指标采集**: `github.com/prometheus/client_golang`
*   **配置管理**: 自行封装一个使用 `sync.RWMutex` 保护的线程安全配置对象。

### 5.2 实施规划 (开发路线图)

**Phase 1: 核心代理与数据结构 (2天)**
*   [x] 初始化Go项目，定义 `config.yaml` 对应的Go `struct` 结构。
*   [x] 实现一个函数，在程序启动时加载并解析 `config.yaml` 文件到内存。
*   [x] **实现核心HTTP Handler**: 完成完整的动态路由逻辑，包括用户认证、查找路由策略、构建并转发请求。
*   [x] 在此阶段，先不实现热加载，确保单次加载配置能完美工作。
*   [x] 建立基础单元测试（`go test`），覆盖配置解析、路由查找和认证注入的关键路径。

**Phase 2: 配置热加载 (1-2天)**
*   [x] 引入 `fsnotify` 库，设置一个goroutine来监控 `config.yaml` 的修改事件。
*   [x] 设计一个线程安全的配置管理器，使用 `sync.RWMutex` 保护配置对象，当文件变更时，解析新配置并原子地替换掉旧的配置指针。
*   [x] 增加配置校验逻辑：在加载新配置时，进行基本的检查（如用户指向的provider和key是否存在），如果校验失败则拒绝加载并打印错误日志，并保持旧配置继续服务。
*   [x] 编写覆盖热加载成功/失败分支的端到端回放测试或脚本，验证回滚机制。

**Phase 3: 日志与可观测性 (1天)**
*   [x] 引入结构化日志库。
*   [x] 为请求处理流程的每个关键步骤（认证、路由决策、转发、完成）添加详细的日志。
*   [x] 实现一个简单的中间件，为每个请求生成一个唯一的 `RequestID`，并贯穿整个日志链。
*   [x] 输出基础指标（如请求计数、延迟分位、配置加载成功/失败次数），为性能目标和运维告警提供基础数据。

**Phase 4: 打包与部署 (1天)**
*   [x] 编写 `Dockerfile` 以便将 `piapi` 应用容器化。
*   [x] 编写一份清晰的 `README.md`，详细说明 `config.yaml` 的配置方法、如何运行服务以及如何获取日志。
*   [x] 交付 `config.yaml.example` 模板文件，方便管理员快速上手。
*   [x] 在目标服务器上部署并进行端到端测试。

## 6. 当前实现状态与交付

*   **Go 版本**: 项目使用 Go 1.23，Docker 镜像基于 `golang:1.23` 构建。
*   **功能覆盖**: 已交付统一网关、配置热加载、Zap 结构化日志、Prometheus 指标（请求计数、延迟、配置重载结果）以及完整的单元/集成测试。
*   **自动化**: GitHub Actions 在 push/PR 时运行 `go test` 和构建流程，对 `main` 与 `v*` 标签自动构建并推送镜像至 `ghcr.io/prehisle/piapi`，附带 `buildcache` 以加速增量构建。
*   **发布产物**: 提供 `config.yaml.example`、`docker-compose.yml`（默认拉取 GHCR 镜像）以及多阶段 `Dockerfile`，支持本地与容器化部署。
*   **后续扩展**: 可按需增加限流、鉴权增强或进一步的部署脚本（如 Helm Chart/系统服务文件）。
